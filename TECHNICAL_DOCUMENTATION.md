# 기술 문서

## 아키텍처 개요

### 시스템 구조
```
[디바이스] --MQTT--> [허브(ESP32)] --MQTT--> [백엔드 서버] --Socket.IO--> [프론트엔드]
                                                      |
                                                      v
                                                [MySQL DB]
```

### 데이터 흐름
1. **디바이스 → 허브**: 센서 데이터 (IR, Red, Green)
2. **허브 → 백엔드**: MQTT를 통한 텔레메트리 데이터 전송
3. **백엔드 처리**: 신호 처리, HR/SpO2 계산, 데이터베이스 저장
4. **백엔드 → 프론트엔드**: Socket.IO를 통한 실시간 데이터 전송
5. **프론트엔드**: 데이터 시각화 및 사용자 인터페이스

---

## MQTT 통신

### 토픽 구조

#### 허브 상태
```
hub/{hubId}/status
```
**메시지 형식:**
```json
{
  "status": "online",
  "timestamp": "2024-12-03T14:31:56.789Z"
}
```

#### 텔레메트리 데이터
```
hub/{hubId}/telemetry/{deviceId}
```
**메시지 형식:**
```json
{
  "device_mac_address": "AA:BB:CC:DD:EE:02",
  "hub_mac_address": "AA:BB:CC:DD:EE:01",
  "timestamp": 1701601916789,
  "starttime": 1701601916000,
  "samples": 50,
  "data": [
    {
      "ir": 12345,
      "red": 12340,
      "green": 12350,
      "spo2": 98.5,
      "hr": 72,
      "temp": 37.2,
      "battery": 85
    }
  ]
}
```

#### 명령 전송
```
hub/{hubId}/command/{deviceId}
```
**메시지 형식:**
```json
{
  "requestId": "req_1234567890_abc123",
  "action": "blink_led",
  "duration": 1000
}
```

#### 명령 응답
```
hub/{hubId}/response/{deviceId}
```
**메시지 형식:**
```json
{
  "requestId": "req_1234567890_abc123",
  "success": true,
  "result": "LED blinked"
}
```

### QoS 레벨
- **QoS 0**: 텔레메트리 데이터 (대량 데이터, 손실 허용)
- **QoS 1**: 허브 상태, 명령 응답 (중요 데이터, 최소 1회 전달 보장)

---

## 신호 처리

### 심박수 계산

#### 1. PI (Perfusion Index) 계산
```
PI = (AC / DC) × 100
```
- **DC**: 신호의 평균값
- **AC**: (최대값 - 최소값) / 2
- **유효성**: PI ≥ 0.3

#### 2. HR 계산 방법

**시간 영역 분석:**
- 피크 검출 기반 HR 계산
- 샘플링 레이트 기반 주기 계산

**주파수 영역 분석:**
- FFT를 통한 주파수 분석
- 최대 파워 주파수에서 HR 추출

**자기 상관 분석:**
- 자기 상관 함수를 통한 주기 검출

#### 3. HR 후보 통합
- **가중 중앙값**: 여러 HR 후보의 가중 중앙값 계산
- **다수결 투표**: 가장 많이 나타나는 HR 값 선택
- **EWMA (지수 가중 이동 평균)**: 시간에 따른 HR 안정화

### SpO2 계산
- Red/IR 신호 비율 기반 계산
- 보정 알고리즘 적용

### 신호 품질 평가 (SQI)
- **PI 기반**: PI 값이 낮으면 신호 품질 낮음
- **파형 주기성**: 파형의 주기성 평가
- **SpO2 변동성**: SpO2 값의 변동성 평가

---

## 데이터 처리

### Telemetry Worker

#### 큐 시스템
- **최대 크기**: 10,000개
- **처리 방식**: 배치 처리
- **오버플로우**: 오래된 데이터 자동 제거

#### 처리 단계
1. **큐에 추가**: MQTT에서 받은 데이터를 큐에 추가
2. **배치 처리**: 일정 개수 이상 모이면 배치 처리
3. **신호 처리**: HR, SpO2 계산
4. **데이터베이스 저장**: Telemetry 테이블에 저장
5. **CSV 파일 작성**: CSV 파일에 원본 데이터 저장
6. **Socket.IO 전송**: 프론트엔드로 실시간 전송

### CSV 파일 구조

#### 파일명 형식
```
{deviceAddress}_{petName}_{timestamp}.csv
```
예: `AA_BB_CC_DD_EE_02_뽀삐_14_31_56_789.csv`

#### 디렉토리 구조
```
csv_files/
  └── {date}/
      └── {deviceAddress}/
          └── {petName}/
              └── {filename}.csv
```

#### CSV 컬럼
```csv
timestamp,ir,red,green,spo2,hr,temp,battery
1701601916789,12345,12340,12350,98.5,72,37.2,85
```

---

## HRV 분석

### 분석 지표

#### 시간 영역 지표
- **SDNN**: RR 간격의 표준편차
- **RMSSD**: 연속된 RR 간격 차이의 제곱근 평균
- **pNN50**: RR 간격 차이가 50ms 이상인 비율
- **Mean RR**: 평균 RR 간격

#### 주파수 영역 지표
- **LF (Low Frequency)**: 0.04-0.15 Hz
- **HF (High Frequency)**: 0.15-0.4 Hz
- **LF/HF 비율**: 자율신경계 균형 지표

#### 복잡도 분석
- **Sample Entropy**: 신호의 복잡도 측정
- **DFA (Detrended Fluctuation Analysis)**: 장기 상관관계 분석

#### Poincaré Plot
- **SD1**: 단기 변동성
- **SD2**: 장기 변동성
- **SD1/SD2 비율**: 자율신경계 균형

### 분석 프로세스
1. **CSV 파일 읽기**: RR 간격 데이터 추출
2. **전처리**: 이상치 제거, 보간
3. **지표 계산**: 시간/주파수/복잡도 지표 계산
4. **시각화**: Poincaré Plot, RR Interval Chart 생성
5. **결과 표시**: 분석 결과 및 해석 제공

---

## 에러 처리

### SpO2 에러 코드

#### SpO2 = 7 (배터리 부족)
- **동작**: 이전 유효 HR 값 ±5 범위 내 랜덤 값 표시
- **토스트**: "배터리가 부족합니다" (첫 발생 시 1회)

#### SpO2 = 8 (신호 불량)
- **동작**: 심박수 0 표시
- **토스트**: "신호가 불량합니다" (연속 3회 발생 시)

#### SpO2 = 9 (움직임 감지)
- **동작**: 이전 유효 HR 값 ±5 범위 내 랜덤 값 표시
- **토스트**: "{환자명}이/가 움직이고 있어 측정이 불가 합니다" (발생 시마다)

### HR 값 처리

#### HR 10-50 범위
- **처리**: HR × 1.6 (소수점 제거)
- **이유**: 센서 값이 실제 HR의 0.625배로 들어오는 경우 보정

---

## 성능 최적화

### 백엔드
- **배치 처리**: Telemetry 데이터 배치 처리로 DB 부하 감소
- **큐 시스템**: 메모리 사용량 제한 (최대 10,000개)
- **인덱스**: 데이터베이스 인덱스 최적화
- **연결 풀링**: Sequelize 연결 풀 설정

### 프론트엔드
- **React.memo**: 불필요한 리렌더링 방지
- **useMemo**: 계산 비용이 큰 값 메모이제이션
- **가상화**: 대량 데이터 리스트 가상화 (필요 시)
- **코드 스플리팅**: 라우트별 코드 스플리팅

---

## 보안

### 인증
- **JWT**: 토큰 기반 인증
- **토큰 만료**: 24시간
- **비밀번호 해싱**: bcryptjs (salt rounds: 10)

### 입력 검증
- **MAC 주소**: 형식 검증 (AA:BB:CC:DD:EE:FF)
- **이메일**: 형식 검증
- **비밀번호**: 최소 길이, 복잡도 검증
- **경로 조작**: Path Traversal 방지

### 데이터 보호
- **사용자별 접근 제한**: 소유권 확인
- **SQL Injection 방지**: Sequelize ORM 사용
- **XSS 방지**: 입력 데이터 이스케이프

---

## 모니터링

### 로그
- **MQTT 메시지**: 실시간 로그 출력
- **에러 로그**: 전역 에러 핸들러를 통한 에러 로깅
- **성능 로그**: Telemetry 큐 크기 모니터링

### 상태 체크
- **허브 상태**: 온라인/오프라인 추적
- **디바이스 상태**: 연결 상태 추적
- **데이터베이스 연결**: 연결 상태 모니터링
- **MQTT 연결**: 연결 상태 모니터링

---

## 확장성

### 수평 확장
- **로드 밸런서**: 여러 백엔드 인스턴스
- **세션 공유**: Redis를 통한 세션 공유
- **MQTT 브로커 클러스터**: MQTT 브로커 클러스터링

### 수직 확장
- **서버 리소스**: CPU, 메모리 증설
- **데이터베이스**: 읽기 전용 복제본
- **캐싱**: Redis를 통한 데이터 캐싱

---

## 문제 해결

### 일반적인 문제

#### MQTT 메시지가 수신되지 않음
1. MQTT 브로커 실행 상태 확인
2. 토픽 구독 확인
3. 네트워크 연결 확인
4. 방화벽 설정 확인

#### 데이터베이스 연결 실패
1. MySQL 서버 실행 상태 확인
2. 환경 변수 확인
3. 데이터베이스 권한 확인
4. 네트워크 연결 확인

#### Socket.IO 연결 실패
1. CORS 설정 확인
2. 네트워크 연결 확인
3. 브라우저 콘솔 확인
4. 서버 로그 확인

### 디버깅

#### 백엔드
```bash
# 상세 로그 활성화
NODE_ENV=development DB_LOGGING=true npm run dev
```

#### 프론트엔드
- 브라우저 개발자 도구 콘솔
- React DevTools
- Network 탭에서 API 요청 확인

---

## 참고 자료

### 문서
- [Express.js 공식 문서](https://expressjs.com/)
- [Socket.IO 공식 문서](https://socket.io/)
- [MQTT 공식 문서](https://mqtt.org/)
- [Sequelize 공식 문서](https://sequelize.org/)
- [React 공식 문서](https://react.dev/)

### 표준
- MQTT 3.1.1 프로토콜
- JWT (RFC 7519)
- WebSocket (RFC 6455)


